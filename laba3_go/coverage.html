
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>classes-project: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">classes-project/ChainHashTabel.go (87.2%)</option>
				
				<option value="file1">classes-project/DoublyList.go (85.9%)</option>
				
				<option value="file2">classes-project/ForwardList.go (88.1%)</option>
				
				<option value="file3">classes-project/OpenHashTabel.go (92.3%)</option>
				
				<option value="file4">classes-project/array.go (100.0%)</option>
				
				<option value="file5">classes-project/binaryTree.go (92.4%)</option>
				
				<option value="file6">classes-project/queue.go (100.0%)</option>
				
				<option value="file7">classes-project/stack.go (95.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package classes

// =======================
// constants
// =======================

const chainTableSize = 10 // аналог CHAIN_TABLE_SIZE

// =======================
// private node
// =======================

type chainNode struct {
  key   string
  value string
  next  *chainNode
}

// =======================
// ChainHashTable (PUBLIC)
// =======================

type ChainHashTable struct {
  table [chainTableSize]*chainNode // private
}

// =======================
// Constructor
// =======================

func NewChainHashTable() *ChainHashTable <span class="cov8" title="1">{
  ht := &amp;ChainHashTable{}
  for i := 0; i &lt; chainTableSize; i++ </span><span class="cov8" title="1">{
    ht.table[i] = nil
  }</span>
  <span class="cov8" title="1">return ht</span>
}

// =======================
// private hash function
// =======================

func (ht *ChainHashTable) hashFun(key string) int <span class="cov8" title="1">{
  hash := 0
  for _, ch := range key </span><span class="cov8" title="1">{
    hash += int(ch)
  }</span>
  <span class="cov8" title="1">return hash % chainTableSize</span>
}

// =======================
// Public methods
// =======================

func (ht *ChainHashTable) Contains(key string) bool <span class="cov8" title="1">{
  h := ht.hashFun(key)
  curr := ht.table[h]

  for curr != nil </span><span class="cov8" title="1">{
    if curr.key == key </span><span class="cov8" title="1">{
      return true
    }</span>
    <span class="cov0" title="0">curr = curr.next</span>
  }
  <span class="cov8" title="1">return false</span>
}

func (ht *ChainHashTable) Get(key string) string <span class="cov8" title="1">{
  h := ht.hashFun(key)
  curr := ht.table[h]

  for curr != nil </span><span class="cov8" title="1">{
    if curr.key == key </span><span class="cov8" title="1">{
      return curr.value
    }</span>
    <span class="cov0" title="0">curr = curr.next</span>
  }
  <span class="cov8" title="1">return ""</span>
}

func (ht *ChainHashTable) Insert(key, value string) bool <span class="cov8" title="1">{
  if ht.Contains(key) </span><span class="cov8" title="1">{
    return false
  }</span>

  <span class="cov8" title="1">h := ht.hashFun(key)
  newNode := &amp;chainNode{
    key:   key,
    value: value,
    next:  ht.table[h],
  }
  ht.table[h] = newNode
  return true</span>
}

func (ht *ChainHashTable) Remove(key string) <span class="cov8" title="1">{
  h := ht.hashFun(key)
  curr := ht.table[h]
  var prev *chainNode = nil

  for curr != nil </span><span class="cov8" title="1">{
    if curr.key == key </span><span class="cov8" title="1">{
      if prev != nil </span><span class="cov0" title="0">{
        prev.next = curr.next
      }</span> else<span class="cov8" title="1"> {
        ht.table[h] = curr.next
      }</span>
      <span class="cov8" title="1">return</span>
    }
    <span class="cov0" title="0">prev = curr
    curr = curr.next</span>
  }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package classes

import (
  "fmt"
)


type nodeDL struct {
  data string
  prev *nodeDL
  next *nodeDL
}


type DoublyList struct {
  head *nodeDL // private поле
  tail *nodeDL // private поле
}



func NewDL() *DoublyList <span class="cov0" title="0">{
  return &amp;DoublyList{}
}</span>


func (l *DoublyList) find(value string) *nodeDL <span class="cov8" title="1">{
  cur := l.head
  for cur != nil </span><span class="cov8" title="1">{
    if cur.data == value </span><span class="cov8" title="1">{
      return cur
    }</span>
    <span class="cov8" title="1">cur = cur.next</span>
  }
  <span class="cov8" title="1">return nil</span>
}

func (l *DoublyList) AddHead(value string) <span class="cov8" title="1">{
  newNode := &amp;nodeDL{data: value, next: l.head}
  if l.head != nil </span><span class="cov8" title="1">{
    l.head.prev = newNode
  }</span> else<span class="cov8" title="1"> {
    l.tail = newNode
  }</span>
  <span class="cov8" title="1">l.head = newNode</span>
}

func (l *DoublyList) AddTail(value string) <span class="cov8" title="1">{
  newNode := &amp;nodeDL{data: value, prev: l.tail}
  if l.tail != nil </span><span class="cov8" title="1">{
    l.tail.next = newNode
  }</span> else<span class="cov8" title="1"> {
    l.head = newNode
  }</span>
  <span class="cov8" title="1">l.tail = newNode</span>
}

func (l *DoublyList) AddAfter(target, value string) <span class="cov8" title="1">{
  ptr := l.find(target)
  if ptr == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">newNode := &amp;nodeDL{data: value, prev: ptr, next: ptr.next}
  if ptr.next != nil </span><span class="cov8" title="1">{
    ptr.next.prev = newNode
  }</span> else<span class="cov8" title="1"> {
    l.tail = newNode
  }</span>
  <span class="cov8" title="1">ptr.next = newNode</span>
}

func (l *DoublyList) AddBefore(target, value string) <span class="cov8" title="1">{
  ptr := l.find(target)
  if ptr == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">if ptr.prev == nil </span><span class="cov0" title="0">{
    l.AddHead(value)
    return
  }</span>

  <span class="cov8" title="1">newNode := &amp;nodeDL{data: value, prev: ptr.prev, next: ptr}
  ptr.prev.next = newNode
  ptr.prev = newNode</span>
}

func (l *DoublyList) DeleteHead() <span class="cov8" title="1">{
  if l.head == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">tmp := l.head
  l.head = tmp.next

  if l.head != nil </span><span class="cov8" title="1">{
    l.head.prev = nil
  }</span> else<span class="cov0" title="0"> {
    l.tail = nil
  }</span>
}

func (l *DoublyList) DeleteTail() <span class="cov8" title="1">{
  if l.tail == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">tmp := l.tail
  l.tail = tmp.prev

  if l.tail != nil </span><span class="cov8" title="1">{
    l.tail.next = nil
  }</span> else<span class="cov0" title="0"> {
    l.head = nil
  }</span>
}

func (l *DoublyList) DeleteAfter(target string) <span class="cov8" title="1">{
  ptr := l.find(target)
  if ptr == nil || ptr.next == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">tmp := ptr.next
  ptr.next = tmp.next

  if tmp.next != nil </span><span class="cov8" title="1">{
    tmp.next.prev = ptr
  }</span> else<span class="cov8" title="1"> {
    l.tail = ptr
  }</span>
}

func (l *DoublyList) DeleteBefore(target string) <span class="cov8" title="1">{
  ptr := l.find(target)
  if ptr == nil || ptr.prev == nil </span><span class="cov0" title="0">{
    return
  }</span>

  <span class="cov8" title="1">tmp := ptr.prev
  ptr.prev = tmp.prev

  if tmp.prev != nil </span><span class="cov8" title="1">{
    tmp.prev.next = ptr
  }</span> else<span class="cov0" title="0"> {
    l.head = ptr
  }</span>
}

func (l *DoublyList) DeleteByValue(value string) <span class="cov8" title="1">{
  ptr := l.find(value)
  if ptr == nil </span><span class="cov8" title="1">{
    return
  }</span>

  <span class="cov8" title="1">if ptr == l.head </span><span class="cov8" title="1">{
    l.DeleteHead()
    return
  }</span>
  <span class="cov8" title="1">if ptr == l.tail </span><span class="cov8" title="1">{
    l.DeleteTail()
    return
  }</span>

  <span class="cov8" title="1">ptr.prev.next = ptr.next
  ptr.next.prev = ptr.prev</span>
}

func (l *DoublyList) PrintForward() <span class="cov8" title="1">{
  cur := l.head
  for cur != nil </span><span class="cov8" title="1">{
    fmt.Print(cur.data, " ")
    cur = cur.next
  }</span>
  <span class="cov8" title="1">fmt.Println()</span>
}

func (l *DoublyList) PrintBackward() <span class="cov8" title="1">{
  cur := l.tail
  for cur != nil </span><span class="cov8" title="1">{
    fmt.Print(cur.data, " ")
    cur = cur.prev
  }</span>
  <span class="cov8" title="1">fmt.Println()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package classes

import (
    "fmt"
)

type nodeFL struct {
    data string
    next *nodeFL
}

type ForwardList struct {
    head *nodeFL
}

// ===== constructor / destructor =====

func NewFL() *ForwardList <span class="cov0" title="0">{
    return &amp;ForwardList{head: nil}
}</span>

func (l *ForwardList) Clear() <span class="cov8" title="1">{
    l.head = nil // GC всё подчистит
}</span>

// ===== helpers =====

func (l *ForwardList) Find(value string) *nodeFL <span class="cov8" title="1">{
    cur := l.head
    for cur != nil </span><span class="cov8" title="1">{
        if cur.data == value </span><span class="cov8" title="1">{
            return cur
        }</span>
        <span class="cov8" title="1">cur = cur.next</span>
    }
    <span class="cov8" title="1">return nil</span>
}

// ===== queries =====

func (l *ForwardList) Contains(value string) bool <span class="cov8" title="1">{
    return l.Find(value) != nil
}</span>

func (l *ForwardList) ToSlice() []string <span class="cov8" title="1">{
    var out []string
    cur := l.head
    for cur != nil </span><span class="cov8" title="1">{
        out = append(out, cur.data)
        cur = cur.next
    }</span>
    <span class="cov8" title="1">return out</span>
}

// ===== add =====

func (l *ForwardList) AddHead(value string) <span class="cov8" title="1">{
    l.head = &amp;nodeFL{data: value, next: l.head}
}</span>

func (l *ForwardList) AddTail(value string) <span class="cov8" title="1">{
    newNode := &amp;nodeFL{data: value}
    if l.head == nil </span><span class="cov8" title="1">{
        l.head = newNode
        return
    }</span>
    <span class="cov8" title="1">cur := l.head
    for cur.next != nil </span><span class="cov8" title="1">{
        cur = cur.next
    }</span>
    <span class="cov8" title="1">cur.next = newNode</span>
}

func (l *ForwardList) AddAfter(target, value string) <span class="cov8" title="1">{
    if l.head == nil </span><span class="cov0" title="0">{
        fmt.Println("Список пуст")
        return
    }</span>
    <span class="cov8" title="1">ptr := l.Find(target)
    if ptr == nil </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov8" title="1">ptr.next = &amp;nodeFL{data: value, next: ptr.next}</span>
}

func (l *ForwardList) AddBefore(target, value string) <span class="cov8" title="1">{
    if l.head == nil </span><span class="cov0" title="0">{
        fmt.Println("Список пуст")
        return
    }</span>
    <span class="cov8" title="1">if l.head.data == target </span><span class="cov8" title="1">{
        l.AddHead(value)
        return
    }</span>

    <span class="cov8" title="1">cur := l.head
    for cur.next != nil &amp;&amp; cur.next.data != target </span><span class="cov0" title="0">{
        cur = cur.next
    }</span>
    <span class="cov8" title="1">if cur.next != nil </span><span class="cov8" title="1">{
        cur.next = &amp;nodeFL{data: value, next: cur.next}
    }</span>
}

// ===== delete =====

func (l *ForwardList) DeleteHead() <span class="cov8" title="1">{
    if l.head != nil </span><span class="cov8" title="1">{
        l.head = l.head.next
    }</span>
}

func (l *ForwardList) DeleteTail() <span class="cov8" title="1">{
    if l.head == nil </span><span class="cov8" title="1">{
        return
    }</span>
    <span class="cov8" title="1">if l.head.next == nil </span><span class="cov8" title="1">{
        l.head = nil
        return
    }</span>
    <span class="cov8" title="1">cur := l.head
    for cur.next.next != nil </span><span class="cov8" title="1">{
        cur = cur.next
    }</span>
    <span class="cov8" title="1">cur.next = nil</span>
}

func (l *ForwardList) DeleteAfter(target string) <span class="cov8" title="1">{
    ptr := l.Find(target)
    if ptr == nil || ptr.next == nil </span><span class="cov8" title="1">{
        return
    }</span>
    <span class="cov8" title="1">ptr.next = ptr.next.next</span>
}

func (l *ForwardList) DeleteBefore(target string) <span class="cov8" title="1">{
    if l.head == nil || l.head.next == nil || l.head.data == target </span><span class="cov0" title="0">{
        return
    }</span>

    <span class="cov8" title="1">var prev *nodeFL
    cur := l.head

    for cur.next != nil &amp;&amp; cur.next.data != target </span><span class="cov8" title="1">{
        prev = cur
        cur = cur.next
    }</span>

    <span class="cov8" title="1">if cur.next == nil </span><span class="cov8" title="1">{
        return
    }</span>

    <span class="cov8" title="1">if prev == nil </span><span class="cov8" title="1">{
        l.DeleteHead()
    }</span> else<span class="cov0" title="0"> {
        prev.next = cur.next
    }</span>
}

func (l *ForwardList) DeleteValue(value string) <span class="cov8" title="1">{
    if l.head == nil </span><span class="cov8" title="1">{
        return
    }</span>
    <span class="cov8" title="1">if l.head.data == value </span><span class="cov8" title="1">{
        l.DeleteHead()
        return
    }</span>

    <span class="cov8" title="1">cur := l.head
    for cur.next != nil &amp;&amp; cur.next.data != value </span><span class="cov0" title="0">{
        cur = cur.next
    }</span>
    <span class="cov8" title="1">if cur.next != nil </span><span class="cov8" title="1">{
        cur.next = cur.next.next
    }</span>
}

// ===== print =====

func (l *ForwardList) Print() <span class="cov8" title="1">{
    cur := l.head
    for cur != nil </span><span class="cov8" title="1">{
        fmt.Print(cur.data, " ")
        cur = cur.next
    }</span>
    <span class="cov8" title="1">fmt.Println()</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package classes

import "fmt"

// =======================
// constants
// =======================

const openTableSize = 10 // аналог OPEN_TABLE_SIZE

// =======================
// private entry
// =======================

type openEntry struct {
  key   string
  value string
  used  bool
}

// =======================
// HashTableOpen (PUBLIC)
// =======================

type HashTableOpen struct {
  table [openTableSize]openEntry // private
}

// =======================
// Constructor
// =======================

func NewHashTableOpen() *HashTableOpen <span class="cov8" title="1">{
  ht := &amp;HashTableOpen{}
  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    ht.table[i] = openEntry{
      key:   "",
      value: "",
      used:  false,
    }
  }</span>
  <span class="cov8" title="1">return ht</span>
}

// =======================
// private hash function
// =======================

func (ht *HashTableOpen) hashFun(key string) int <span class="cov8" title="1">{
  hash := 0
  for _, ch := range key </span><span class="cov8" title="1">{
    hash += int(ch)
  }</span>
  <span class="cov8" title="1">return hash % openTableSize</span>
}

// =======================
// Public methods
// =======================

func (ht *HashTableOpen) Insert(value, key string) bool <span class="cov8" title="1">{
  if key == "" </span><span class="cov8" title="1">{
    return false
  }</span>

  <span class="cov8" title="1">h := ht.hashFun(key)

  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    idx := (h + i) % openTableSize

    if !ht.table[idx].used </span><span class="cov8" title="1">{
      ht.table[idx] = openEntry{
        key:   key,
        value: value,
        used:  true,
      }
      return true
    }</span>

    <span class="cov8" title="1">if ht.table[idx].key == key </span><span class="cov8" title="1">{
      return false
    }</span>
  }
  <span class="cov8" title="1">return false</span>
}

func (ht *HashTableOpen) Get(key string) string <span class="cov8" title="1">{
  h := ht.hashFun(key)

  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    idx := (h + i) % openTableSize

    if !ht.table[idx].used </span><span class="cov8" title="1">{
      return ""
    }</span>

    <span class="cov8" title="1">if ht.table[idx].key == key </span><span class="cov8" title="1">{
      return ht.table[idx].value
    }</span>
  }
  <span class="cov0" title="0">return ""</span>
}

func (ht *HashTableOpen) Contains(key string) bool <span class="cov8" title="1">{
  h := ht.hashFun(key)

  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    idx := (h + i) % openTableSize

    if !ht.table[idx].used </span><span class="cov8" title="1">{
      return false
    }</span>

    <span class="cov8" title="1">if ht.table[idx].key == key </span><span class="cov8" title="1">{
      return true
    }</span>
  }
  <span class="cov0" title="0">return false</span>
}

func (ht *HashTableOpen) Remove(key string) bool <span class="cov8" title="1">{
  h := ht.hashFun(key)

  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    idx := (h + i) % openTableSize

    if !ht.table[idx].used </span><span class="cov8" title="1">{
      return false
    }</span>

    <span class="cov8" title="1">if ht.table[idx].key == key </span><span class="cov8" title="1">{
      ht.table[idx] = openEntry{
        key:   "",
        value: "",
        used:  false,
      }
      return true
    }</span>
  }
  <span class="cov0" title="0">return false</span>
}

func (ht *HashTableOpen) PrintTable() <span class="cov8" title="1">{
  fmt.Println("Хэш-таблица (ключ -&gt; значение):")
  for i := 0; i &lt; openTableSize; i++ </span><span class="cov8" title="1">{
    fmt.Print(i, ": ")
    if ht.table[i].used </span><span class="cov8" title="1">{
      fmt.Printf("'%s' -&gt; '%s'", ht.table[i].key, ht.table[i].value)
    }</span> else<span class="cov8" title="1"> {
      fmt.Print("-")
    }</span>
    <span class="cov8" title="1">fmt.Println()</span>
  }
}

// =======================
// Debug (для тестов)
// =======================

func (ht *HashTableOpen) DebugIndex(key string) int <span class="cov0" title="0">{
  return ht.hashFun(key)
}</pre>
		
		<pre class="file" id="file4" style="display: none">package classes

import (
  "fmt"
)

type Array struct { // PUBLIC
  data     []string // private
  size     int      // private
  capacity int      // private
}

// =======================
// Constructor
// =======================

func NewArray() *Array <span class="cov8" title="1">{ // PUBLIC
  return &amp;Array{
    data:     make([]string, 2),
    size:     0,
    capacity: 2,
  }
}</span>

// =======================
// Private helper
// =======================

func (a *Array) resize(newCapacity int) <span class="cov8" title="1">{ // PRIVATE
  newData := make([]string, newCapacity)
  copy(newData, a.data)
  a.data = newData
  a.capacity = newCapacity
}</span>

// =======================
// Public methods
// =======================

func (a *Array) PushBack(value string) <span class="cov8" title="1">{
  if a.size &gt;= a.capacity </span><span class="cov8" title="1">{
    a.resize(a.capacity * 2)
  }</span>
  <span class="cov8" title="1">a.data[a.size] = value
  a.size++</span>
}

func (a *Array) Insert(index int, value string) <span class="cov8" title="1">{
  if index &lt; 0 || index &gt; a.size </span><span class="cov8" title="1">{
    fmt.Println("Ошибка: индекс вне диапазона")
    return
  }</span>

  <span class="cov8" title="1">a.PushBack("")
  for i := a.size - 1; i &gt; index; i-- </span><span class="cov8" title="1">{
    a.data[i] = a.data[i-1]
  }</span>
  <span class="cov8" title="1">a.data[index] = value</span>
}

func (a *Array) Delete(index int) <span class="cov8" title="1">{
  if a.size == 0 </span><span class="cov8" title="1">{
    fmt.Println("Массив пуст")
    return
  }</span>
  <span class="cov8" title="1">if index &lt; 0 || index &gt;= a.size </span><span class="cov8" title="1">{
    fmt.Println("Ошибка: индекс вне диапазона")
    return
  }</span>

  <span class="cov8" title="1">for i := index; i &lt; a.size-1; i++ </span><span class="cov8" title="1">{
    a.data[i] = a.data[i+1]
  }</span>
  <span class="cov8" title="1">a.size--</span>
}

func (a *Array) Get(index int) string <span class="cov8" title="1">{
  if index &lt; 0 || index &gt;= a.size </span><span class="cov8" title="1">{
    return ""
  }</span>
  <span class="cov8" title="1">return a.data[index]</span>
}

func (a *Array) Replace(index int, value string) <span class="cov8" title="1">{
  if index &lt; 0 || index &gt;= a.size </span><span class="cov8" title="1">{
    return
  }</span>
  <span class="cov8" title="1">a.data[index] = value</span>
}

func (a *Array) Length() int <span class="cov8" title="1">{
  return a.size
}</span>

func (a *Array) Print() <span class="cov8" title="1">{
  if a.size == 0 </span><span class="cov8" title="1">{
    fmt.Println("Массив пуст")
    return
  }</span>

  <span class="cov8" title="1">fmt.Print("Массив: ")
  for i := 0; i &lt; a.size; i++ </span><span class="cov8" title="1">{
    fmt.Print(a.data[i], " ")
  }</span>
  <span class="cov8" title="1">fmt.Println()</span>
}

</pre>
		
		<pre class="file" id="file5" style="display: none">package classes

import (
  "container/list"
  "fmt"
)

// =======================
// TreeNode (private)
// =======================
type treeNode struct {
  data  int
  left  *treeNode
  right *treeNode
}

// =======================
// CompleteBinaryTree (public)
// =======================
type CompleteBinaryTree struct {
  root *treeNode // приватный корень
}

// =======================
// Constructor
// =======================
func NewCompleteBinaryTree() *CompleteBinaryTree <span class="cov8" title="1">{
  return &amp;CompleteBinaryTree{root: nil}
}</span>

// =======================
// Insert (tInsert)
// =======================
func (t *CompleteBinaryTree) Insert(value int) <span class="cov8" title="1">{
  node := &amp;treeNode{data: value}
  if t.root == nil </span><span class="cov8" title="1">{
    t.root = node
    return
  }</span>

  <span class="cov8" title="1">q := list.New()
  q.PushBack(t.root)

  for q.Len() &gt; 0 </span><span class="cov8" title="1">{
    cur := q.Remove(q.Front()).(*treeNode)

    if cur.left == nil </span><span class="cov8" title="1">{
      cur.left = node
      return
    }</span> else<span class="cov8" title="1"> {
      q.PushBack(cur.left)
    }</span>

    <span class="cov8" title="1">if cur.right == nil </span><span class="cov8" title="1">{
      cur.right = node
      return
    }</span> else<span class="cov8" title="1"> {
      q.PushBack(cur.right)
    }</span>
  }
}

// =======================
// Search (tSearch)
// =======================
func (t *CompleteBinaryTree) Search(value int) bool <span class="cov8" title="1">{
  if t.root == nil </span><span class="cov8" title="1">{
    return false
  }</span>

  <span class="cov8" title="1">q := list.New()
  q.PushBack(t.root)

  for q.Len() &gt; 0 </span><span class="cov8" title="1">{
    cur := q.Remove(q.Front()).(*treeNode)
    if cur.data == value </span><span class="cov8" title="1">{
      return true
    }</span>
    <span class="cov8" title="1">if cur.left != nil </span><span class="cov8" title="1">{
      q.PushBack(cur.left)
    }</span>
    <span class="cov8" title="1">if cur.right != nil </span><span class="cov8" title="1">{
      q.PushBack(cur.right)
    }</span>
  }
  <span class="cov8" title="1">return false</span>
}

// =======================
// IsComplete
// =======================
func (t *CompleteBinaryTree) IsComplete() bool <span class="cov8" title="1">{
  if t.root == nil </span><span class="cov8" title="1">{
    return true
  }</span>

  <span class="cov8" title="1">q := list.New()
  q.PushBack(t.root)
  flag := false

  for q.Len() &gt; 0 </span><span class="cov8" title="1">{
    cur := q.Remove(q.Front()).(*treeNode)

    if cur.left != nil </span><span class="cov8" title="1">{
      if flag </span><span class="cov0" title="0">{
        return false
      }</span>
      <span class="cov8" title="1">q.PushBack(cur.left)</span>
    } else<span class="cov8" title="1"> {
      flag = true
    }</span>

    <span class="cov8" title="1">if cur.right != nil </span><span class="cov8" title="1">{
      if flag </span><span class="cov0" title="0">{
        return false
      }</span>
      <span class="cov8" title="1">q.PushBack(cur.right)</span>
    } else<span class="cov8" title="1"> {
      flag = true
    }</span>
  }
  <span class="cov8" title="1">return true</span>
}

// =======================
// Print (printTNode / printT)
// =======================
func (t *CompleteBinaryTree) Print() <span class="cov8" title="1">{
  t.printNode(t.root, 0)
}</span>

func (t *CompleteBinaryTree) printNode(node *treeNode, indent int) <span class="cov8" title="1">{
  if node == nil </span><span class="cov8" title="1">{
    return
  }</span>
  <span class="cov8" title="1">if node.right != nil </span><span class="cov0" title="0">{
    t.printNode(node.right, indent+4)
  }</span>
  <span class="cov8" title="1">if indent &gt; 0 </span><span class="cov0" title="0">{
    fmt.Print(fmt.Sprintf("%*s", indent, ""))
  }</span>
  <span class="cov8" title="1">fmt.Println(node.data)
  if node.left != nil </span><span class="cov0" title="0">{
    t.printNode(node.left, indent+4)
  }</span>
}

// =======================
// Clear (private, like clear(root))
// =======================
func (t *CompleteBinaryTree) clear() <span class="cov8" title="1">{
  t.clearNode(t.root)
  t.root = nil
}</span>

func (t *CompleteBinaryTree) clearNode(node *treeNode) <span class="cov8" title="1">{
  if node == nil </span><span class="cov8" title="1">{
    return
  }</span>
  <span class="cov8" title="1">t.clearNode(node.left)
  t.clearNode(node.right)
  node.left = nil
  node.right = nil</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package classes

import (
  "fmt"
)

// =======================
// private node
// =======================

type queueNode struct {
  data string
  next *queueNode
}

// =======================
// Queue (PUBLIC)
// =======================

type Queue struct {
  front *queueNode // private
  rear  *queueNode // private
}

// =======================
// Constructor
// =======================

func NewQueue() *Queue <span class="cov8" title="1">{ // PUBLIC
  return &amp;Queue{
    front: nil,
    rear:  nil,
  }
}</span>

// =======================
// Public methods
// =======================

// добавление в конец очереди
func (q *Queue) Push(value string) <span class="cov8" title="1">{
  newNode := &amp;queueNode{
    data: value,
    next: nil,
  }

  if q.rear == nil </span><span class="cov8" title="1">{ // очередь пустая
    q.front = newNode
    q.rear = newNode
    return
  }</span>

  <span class="cov8" title="1">q.rear.next = newNode
  q.rear = newNode</span>
}

// удаление первого элемента
func (q *Queue) Pop() string <span class="cov8" title="1">{
  if q.front == nil </span><span class="cov8" title="1">{
    return ""
  }</span>

  <span class="cov8" title="1">value := q.front.data
  q.front = q.front.next

  if q.front == nil </span><span class="cov8" title="1">{ // очередь стала пустой
    q.rear = nil
  }</span>

  <span class="cov8" title="1">return value</span>
}

func (q *Queue) IsEmpty() bool <span class="cov8" title="1">{
  return q.front == nil
}</span>

func (q *Queue) Print() <span class="cov8" title="1">{
  if q.IsEmpty() </span><span class="cov8" title="1">{
    fmt.Println("Очередь пуста")
    return
  }</span>

  <span class="cov8" title="1">fmt.Print("Очередь (слева направо): ")
  cur := q.front
  for cur != nil </span><span class="cov8" title="1">{
    fmt.Print(cur.data, " ")
    cur = cur.next
  }</span>
  <span class="cov8" title="1">fmt.Println()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package classes

import (
  "fmt"
)

// =======================
// private node
// =======================

type stackNode struct {
  data string
  next *stackNode
}

// =======================
// Stack (PUBLIC)
// =======================

type Stack struct {
  head *stackNode // private
}

// =======================
// Constructor
// =======================

func NewStack() *Stack <span class="cov8" title="1">{ // PUBLIC
  return &amp;Stack{head: nil}
}</span>

// =======================
// Public methods
// =======================

func (s *Stack) IsEmpty() bool <span class="cov8" title="1">{
  return s.head == nil
}</span>

func (s *Stack) Push(value string) <span class="cov8" title="1">{
  newNode := &amp;stackNode{
    data: value,
    next: s.head,
  }
  s.head = newNode
}</span>

func (s *Stack) Pop() string <span class="cov8" title="1">{
  if s.IsEmpty() </span><span class="cov8" title="1">{
    return ""
  }</span>
  <span class="cov8" title="1">value := s.head.data
  s.head = s.head.next
  return value</span>
}

func (s *Stack) Top() string <span class="cov8" title="1">{
  if s.IsEmpty() </span><span class="cov8" title="1">{
    return ""
  }</span>
  <span class="cov8" title="1">return s.head.data</span>
}

func (s *Stack) Clear() <span class="cov8" title="1">{
  for !s.IsEmpty() </span><span class="cov8" title="1">{
    s.Pop()
  }</span>
}

func (s *Stack) Print() <span class="cov8" title="1">{
  if s.IsEmpty() </span><span class="cov0" title="0">{
    return
  }</span>
  <span class="cov8" title="1">fmt.Print("Стек (верх -&gt; низ): ")
  cur := s.head
  for cur != nil </span><span class="cov8" title="1">{
    fmt.Print(cur.data, " ")
    cur = cur.next
  }</span>
  <span class="cov8" title="1">fmt.Println()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
